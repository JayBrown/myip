#!/bin/zsh
# shellcheck shell=bash

# myip v0.4

export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/opt/local/bin:/opt/sw/bin:/sw/bin:"$HOME"/.local/bin:"$HOME"/bin:"$HOME"/local/bin

process="myip"
vno="0.4"

_ip () {
	if $offline ; then
		echo -e "Public IP:\t-"
	else
		publicip=$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null)
		if [[ $publicip ]] ; then
			echo -e "Public IP:\t$publicip"
			publicname=$(dig +short -x "$publicip" 2>/dev/null | sed 's/\.$//')
			! [[ $publicname ]] && publicname="-"
			echo -e "Public Name:\t$publicname"
			whoisraw=$(whois "$publicip" 2>/dev/null)
			publicorg=$(echo "$whoisraw" | grep -e "^org-name:" -e "^OrgName:" | grep -v "^$" | awk '!a[$0]++' | awk -F":" '{print substr($0, index($0,$2))}' | head -1 | xargs)
			if ! [[ $publicorg ]] ; then
				publicorg=$(echo "$whoisraw" | grep "^descr:" | grep -v "^$" | sort | awk '!a[$0]++' | awk -F":" '{print substr($0, index($0,$2))}' | head -1 | xargs)
			fi
			! [[ $publicorg ]] && publicorg="-"
			echo -e "Provider:\t$publicorg"
			if $rloc ; then
				IFS=$'\n' read -rd '' rcountry rlat rlong < <(curl -sL --connect-timeout 10 --max-time 10 "http://ip-api.com/line/$publicip?fields=193" 2>/dev/null)
				if ! [[ $rlat ]] || ! [[ $rlong ]] ; then
					if ! [[ $rcountry ]] ; then
						rcoord="-"
					else
						rcoord="- ($rcountry)"
					fi
				else
					if ! [[ $rcountry ]] ; then
						rcoord="$rlat,$rlong (-)"
					else
						rcoord="$rlat,$rlong ($rcountry)"
					fi
				fi
				echo -e "Location:\t$rcoord"
			fi
			mcount=0
			secs=3
			while true
			do
				[[ $mcount -eq 3 ]] && break
				mdns_raw=$((dns-sd -X 2>&1) & pid=$! ; (sleep "$secs" && kill -9 $pid 2>/dev/null))
				mdnsip=$(echo "$mdns_raw" | grep -v -e "^DATE" -e "STARTING" -e "^Timestamp" | sed -n '$p' | awk '{print $3}')
				if [[ $mdnsip ]] ; then
					break
				else
					sleep 1
					((mcount++))
					((secs++))
				fi
			done
			! [[ $mdnsip ]] && mdnsip="-"
			[[ $mdnsip == "0.0.0.0" ]] && mdnsip="0.0.0.0 [tunnel]"
			echo -e "mDNS IP:\t$mdnsip"
			gateway=$(echo "$routestat" | awk '/gateway:/ {print $2}')
			if ! [[ $gateway ]] ; then
				arp_raw=$(arp -a 2>/dev/null | head -1)
				gateway=$(echo "$arp_raw" | awk -F"[)(]" '{print $1}' | xargs)
			fi
			if ! [[ $gateway ]] ; then
				routerip="[no gateway]"
			else
				if [[ $gateway == "fritz.box" ]] ; then
					routerip=$(curl "http://fritz.box:49000/igdupnp/control/WANIPConn1" -H "Content-Type: text/xml; charset="utf-8"" -H "SoapAction:urn:schemas-upnp-org:service:WANIPConnection:1#GetExternalIPAddress" -d "<?xml version='1.0' encoding='utf-8'?> <s:Envelope s:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/' xmlns:s='http://schemas.xmlsoap.org/soap/envelope/'> <s:Body> <u:GetExternalIPAddress xmlns:u='urn:schemas-upnp-org:service:WANIPConnection:1' /> </s:Body> </s:Envelope>" -s \
						| grep -Eo '\<[[:digit:]]{1,3}(\.[[:digit:]]{1,3}){3}\>')
				else
					routerip="[AP not supported]"
				fi
			fi
			echo -e "Router IP:\t$routerip"
			if ps aux | grep openvpn | grep root &>/dev/null ; then
				vpndevice=$(netstat -nr | awk '/^0\/1/ {print $4}')
				if [[ $vpndevice ]] ; then
					echo -e "OpenVPN:\t$vpndevice"
					vpnip=$(ifconfig "$vpndevice" 2>/dev/null | grep "inet " | awk '{print $2}')
					! [[ $vpnip ]] && vpnip="-"
					echo -e "OpenVPN IP:\t$vpnip"
				else
					vpndevice="-"
					vpnip="-"
					echo -e "OpenVPN:\t$vpndevice\nOpenVPN IP:\t$vpnip"
				fi
			fi
		else
			echo -e "Public IP:\t-"
		fi
	fi
}

_killbt () {
	transmission-remote --exit &>/dev/null
	sleep .5
	if pgrep transmission-daemon &>/dev/null ; then
		killall transmission-daemon &>/dev/null
	fi
}

_torrent () {		
	if ! command -v transmission-daemon &>/dev/null || ! command -v transmission-remote &>/dev/null ; then
		echo -e "Torrent IP:\tERROR: transmission CLI missing!" >&2
		_killbt
		return
	fi
	if ! pgrep transmission-daemon &>/dev/null ; then
		transmission-daemon &>/dev/null
		if ! pgrep transmission-daemon &>/dev/null ; then
			echo -e "Torrent IP:\tERROR launching transmission-daemon!" >&2
			return
		fi
	fi
	sleep 1
	ipleakbt=$(transmission-remote -l 2>/dev/null | grep "ipleak\.net+torrent+detection$")
	if ! [[ $ipleakbt ]] ; then
		echo -e "Torrent IP:\tERROR: no magnet link found!" >&2
		_killbt
		return
	fi
	btn=$(echo "$ipleakbt" | awk '{print $1}' | sed 's/*$//')
	if ! [[ $btn ]] ; then
		echo -e "Torrent IP:\tERROR parsing IPLeak torrent!" >&2
		_killbt
		return 
	fi
	transmission-remote -t "$btn" -s &>/dev/null
	sleep 1
	btcount=0
	btsleep=1
	while true
	do
		[[ $btcount -eq 3 ]] && break
		tinfo=$(transmission-remote -t "$btn" -i 2>/dev/null | grep "look https\:\/\/ipleak\.net for details\.$")
		[[ $tinfo ]] && break
		sleep "$btsleep"
		((btsleep++))
		((btcount++))
	done
	if ! [[ $tinfo ]] ; then
		echo -e "Torrent IP:\tERROR: torrent info missing!" >&2
		_killbt
		return 
	fi
	torrentip=$(echo "$tinfo" | awk -F"IP:" '{print $2}' | awk -F"," '{print $1}')
	! [[ $torrentip ]] && torrentip="-"
	echo -e "Torrent IP:\t$torrentip"
	_killbt
}

_local () {
	if $localdev ; then
		localip=$(ipconfig getifaddr "$localdevice")
		if ! [[ $localip ]] ; then
			localip=$(ifconfig "$localdevice" 2>/dev/null | grep "inet " | awk '{print $2}')
			! [[ $localip ]] && localip="-"
		fi
	else
		localip="127.0.0.1"
	fi
	echo -e "Local IP:\t$localip"
	nhost=$(scutil --get HostName 2>/dev/null)
	! [[ $nhost ]] && nhost="-"
	echo -e "Host:\t\t$nhost"
	ncomp=$(scutil --get ComputerName 2>/dev/null)
	! [[ $ncomp ]] && ncomp="-"
	echo -e "Computer:\t$ncomp"
	nlocalhost=$(scutil --get LocalHostName 2>/dev/null)
	! [[ $nlocalhost ]] && nlocalhost="-"
	echo -e "LocalHost:\t$nlocalhost"
	macaddr=$(networksetup -getmacaddress "$localdevice" | awk '/Ethernet/ {print $3}')
	! [[ $macaddr ]] && macaddr="-"
	echo -e "MAC:\t\t$macaddr"
	if ! [[ $arp_raw ]] ; then
		arp_raw=$(arp -a 2>/dev/null | head -1)
	fi
	if ! [[ $gateway ]] ; then
		gateway=$(echo "$arp_raw" | awk -F"[)(]" '{print $1}' | xargs)
	fi
	! [[ $gateway ]] && gateway="-"
	echo -e "Gateway:\t$gateway"
	apaddr=$(echo "$arp_raw" | awk -F"[)(]" '{print $2}')
	! [[ $apaddr ]] && apaddr="-"
	echo -e "Gateway IP:\t$apaddr"
	netbios=$(smbutil status -e "$apaddr" 2>/dev/null | awk -F": " '/^Server:/{print $2}')
	! [[ $netbios ]] && netbios="-"
	echo -e "NetBIOS:\t$netbios"
	wifi_raw=$(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -I 2>/dev/null | grep "SSID:")
	if [[ $wifi_raw ]] ; then
		ssid=$(echo "$wifi_raw" | grep -v "BSSID:" | awk -F": " '/SSID:/{print $NF}')
		! [[ $ssid ]] && ssid="-"
		bssid=$(echo "$wifi_raw" | awk -F": " '/BSSID:/{print $NF}')
		! [[ $bssid ]] && bssid="-"
	else
		ssid="-"
		bssid="-"
	fi
	echo -e "SSID:\t\t$ssid"
	echo -e "BSSID:\t\t$bssid"
	apether=$(echo "$arp_raw" | awk -F")" '{print $NF}' | sed -e "s/^ at //" -e "s/ on .*//" | xargs)
	! [[ $apether ]] && apether="-"
	echo -e "AP MAC:\t\t$apether"
}

_dns () {
	if ! $offline ; then
		dcount=0
		dsleep=1
		while true
		do
			[[ $dcount -eq 3 ]] && break
			dnsip=$(dig whoami.akamai.net +short 2>/dev/null)
			[[ $dnsip ]] && break
			sleep "$dsleep"
			((dcount++))
			((dsleep++))
		done
		if [[ $dnsip ]] ; then
			echo -e "DNS IP:\t\t$dnsip"
			dnsname=$(dig +short -x "$dnsip" 2>/dev/null | sed 's/\.$//' | grep -v "^$")
			! [[ $dnsname ]] && dnsname="-"
			echo -e "DNS Name:\t$dnsname"
			dnswhoisraw=$(whois "$dnsip" 2>/dev/null)
			dnsorg=$(echo "$dnswhoisraw" | grep -e "^org-name:" -e "^OrgName:" | grep -v "^$" | awk '!a[$0]++' | awk -F":" '{print substr($0, index($0,$2))}' | head -1 | xargs | grep -v "^$")
			if ! [[ $dnsorg ]] ; then
				dnsorg=$(echo "$dnswhoisraw" | grep "^descr:" | grep -v "^$" | awk '!a[$0]++' | awk -F":" '{print substr($0, index($0,$2))}' | head -1 | xargs | grep -v "^$")
			fi
			! [[ $dnsorg ]] && dnsorg="-"
			echo -e "Provider:\t$dnsorg"
			if $rloc ; then
				$fullip && sleep 1
				IFS=$'\n' read -rd '' rcountry rlat rlong < <(curl -sL --connect-timeout 10 --max-time 10 "http://ip-api.com/line/$dnsip?fields=193" 2>/dev/null)
				if ! [[ $rlat ]] || ! [[ $rlong ]] ; then
					if ! [[ $rcountry ]] ; then
						dnsrcoord="-"
					else
						dnsrcoord="- ($rcountry)"
					fi
				else
					if ! [[ $rcountry ]] ; then
						dnsrcoord="$rlat,$rlong (-)"
					else
						dnsrcoord="$rlat,$rlong ($rcountry)"
					fi
				fi
				echo -e "Location:\t$dnsrcoord"
			fi
		else
			echo -e "DNS IP:\t\t-"
		fi
	fi
	nameservers=$(scutil --dns 2>/dev/null | awk '/^DNS configuration$/,/^DNS configuration \(for scoped queries\)$/' | awk '/^DNS configuration$/,/ \(Not Reachable\)$/' | grep "nameserver\[" | sort | awk '!a[$0]++')
	if [[ $nameservers ]] ; then
		count=1
		while read -r nsip
		do
			! [[ $nsip ]] && nsip="[error]"
			if [[ $count -lt 10 ]] ; then
				dcount="0$count"
			else
				dcount="$count"
			fi
			echo -e "DNS #$dcount:\t$nsip"
			((count++))
		done < <(echo "$nameservers" | awk '{print $NF}')
	else
		echo -e "Name servers:\t-"
	fi
	if $localdev ; then
		localdnsip=$(ipconfig getoption "$localdevice" domain_name_server 2>/dev/null)
		! [[ $localdnsip ]] && localdnsip="-"
	else
		localdnsip="-"
	fi
	echo -e "Local DNS:\t$localdnsip"
}

_geo () {
	geoloc_all=$(osascript 2>/dev/null <<EOG
use framework "CoreLocation"
use framework "Foundation"
use scripting additions

property this : a reference to the current application
property nil : a reference to missing value
property _1 : a reference to reference

property CLLocationManager : a reference to CLLocationManager of this
property kCLLocationAccuracyThreeKilometers : a reference to 3000.0
--------------------------------------------------------------------------------
property running : false
property result : missing value -- Lat./long. or error description
property number : 0 -- Error code
property seconds : 10 -- Maximum time to allow script to run
--------------------------------------------------------------------------------
# IMPLEMENTATION:
my performSelectorOnMainThread:"getLocation" withObject:nil waitUntilDone:true
return my result
--------------------------------------------------------------------------------
# HANDLERS & SCRIPT OBJECTS:
to getLocation()
    set locationManager to CLLocationManager's new()

    locationManager's setDelegate:me
    locationManager's setDesiredAccuracy:kCLLocationAccuracyThreeKilometers

    set my running to true
    set started to current date

    locationManager's startUpdatingLocation()

    repeat while my running
        delay 0.5
        if (current date) - started > my seconds then exit repeat
    end repeat
end getLocation

on locationManager:locationManager didUpdateLocations:locations
    local locationManager, locations

    locationManager's stopUpdatingLocation()

    set my running to false
    set my result to (locations's valueForKey:"coordinate") as record
end locationManager:didUpdateLocations:

on locationManager:locationManager didFailWithError:err
    local locationManager, err

    tell err's code()
        set my number to it
        set my result to item (it + 1) in my enum's kCLError
        if it ≠ 0 then set my running to false
    end tell
end locationManager:didFailWithError:

script enum
    property kCLError : {¬
        "Location Unknown", ¬
        "Denied", ¬
        "Network", ¬
        "Heading Failure", ¬
        "Region Monitoring Denied", ¬
        "Region Monitoring Failure", ¬
        "Region Monitoring Setup Delayed", ¬
        "Region Monitoring Response Delayed", ¬
        "Geocode Found No Result", ¬
        "Geocode Found Partial Result", ¬
        "Geocode Canceled", ¬
        "Deferred Failed", ¬
        "Deferred Not Updating Location", ¬
        "Deferred Accuracy Too Low", ¬
        "Deferred Distance Filtered", ¬
        "Deferred Canceled", ¬
        "Ranging Unavailable", ¬
        "Ranging Failure"}
    property CLAuthorizationStatus : {¬
        "Not Determined", ¬
        "Restricted", ¬
        "Denied", ¬
        "Authorized (Always)", ¬
        "Authorized When In Use"}
end script
---------------------------------------------------------------------------❮END❯
EOG
	)
	geo_error=false
	if ! [[ $geoloc_all ]] ; then
		geoloc_all=$(CoreLocationCLI 2>/dev/null)
		if ! [[ $geoloc_all ]] ; then
			echo -e "Geolocation:\t-"
			geo_error=true
		else
			latitude=$(echo "$geoloc_all" | awk '{print $1}')
			longitude=$(echo "$geoloc_all" | awk '{print $2}')
			echo -e "Geolocation:\t$latitude,$longitude"
		fi
	else
		geoloc_raw=$(echo "$geoloc_all" | awk -F"," '{print $1}')
		latitude=$(echo "$geoloc_raw" | awk -F":" '{print $2}')
		if ! [[ $latitude ]] ; then
			echo -e "Geolocation:\t-"
			geo_error=true
		else
			longitude=$(echo "$geoloc_all" | awk -F":" '{print $3}')
			if ! [[ $longitude ]] ; then
				echo -e "Geolocation:\t-"
				geo_error=true
			else
				echo -e "Geolocation:\t$latitude,$longitude"
			fi
		fi
	fi
}


_help () {
	read -d '' helpdoc <<"EOH"
myip [ARG(s)]

	ip	:	public IP only

	net	:	public & local IPs and related info
	bt	:	torrent IP address (requires transmission CLI & an IP tracking torrent)
	local	:	additional local data like hostname, MAC addresses, SSID etc.
	dns	:	public & local DNS IPs, local resolvers & related info
	loc	:	coordinates & country of public IPs (only with 'net' or 'dns')
	geo	:	local geolocation (latitude & longitude)
	addr	:	local geolocation (address)
	map	:	print URLs to open local geolcation in Apple Maps, OSM or Google Maps

	all	:	all of the above
	
	msg	:	share geolocation & address via Apple Messages (requires terminal-share CLI)
	mail	:	share geolocation & address via Apple Mail (requires terminal-share CLI)

	version	:	version number
	help	:	this help document
EOH
	echo "$helpdoc"
}

simpleip=false
fullip=false
torrent=false
localdata=false
dnsinfo=false
rloc=false
lgeo=false
maps=false
address=false
share=false
message=false
email=false

if ! [[ $1 ]] ; then
	simpleip=true
else
	argsn="$#"
	while test -n "$1"
	do
		case "$1" in
			help)
				if [[ $argsn -eq 1 ]] ; then
					_help
					exit 0
				else
					shift
				fi
				;;
			version)
				if [[ $argsn -eq 1 ]] ; then
					echo "$process $vno"
					exit 0
				else
					shift
				fi
				;;
			ip)
				simpleip=true
				if [[ $argsn -eq 1 ]] ; then
					break
				else
					shift
				fi
				;;
			all)
				simpleip=false
				fullip=true
				torrent=true
				localdata=true
				dnsinfo=true
				rloc=true
				lgeo=true
				address=true
				maps=true
				shift
				;;
			net)
				simpleip=false
				fullip=true
				shift
				;;
			bt)
				torrent=true
				shift
				;;
			local)
				localdata=true
				shift
				;;
			dns)
				dnsinfo=true
				shift
				;;
			loc)
				if [[ $argsn -eq 1 ]] ; then
					_help
					exit 0
				else
					rloc=true
					shift
				fi
				;;
			geo)
				lgeo=true
				shift
				;;
			addr)
				lgeo=true
				address=true
				shift
				;;
			map)
				lgeo=true
				maps=true
				shift
				;;
			msg)
				share=true
				lgeo=true
				address=true
				maps=true
				message=true
				email=false
				shift
				;;
			mail)
				share=true
				lgeo=true
				address=true
				maps=true
				message=false
				email=true
				shift
				;;
			*)
				_help
				exit 0
				;;
		esac
	done
fi

localdev=true
routestat=$(route get 0.0.0.0 2>&1)
localdevice=$(echo "$routestat" | awk -F": " '/interface:/{print $2}')
if ! [[ $localdevice ]] ; then
	echo "ERROR: no route" >&2
	localdev=false
	localdevice="-"
fi
service=$(networksetup -listnetworkserviceorder 2>/dev/null | grep -B1 "Device: $localdevice)$" | head -1 | awk -F")" '{print substr($0, index($0,$2))}' | xargs)
! [[ $service ]] && service="-"
offline=false
if ! ping -q -c 1 1.1.1.1 &>/dev/null ; then
	echo "ERROR: offline" >&2
	offline=true
fi
if $simpleip ; then
	publicip=$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null)
	! [[ $publicip ]] && publicip="-"
	echo -e "Public IP:\t$publicip"
fi

if $fullip ; then
	_ip
	if $torrent ; then
		_torrent
	fi
	echo -e "Device:\t\t$localdevice"
	echo -e "Service:\t$service"
	if $localdata ; then
		_local
	fi
	if $dnsinfo ; then
		_dns
	fi
else
	if $torrent ; then
		echo -e "Device:\t\t$localdevice"
		echo -e "Service:\t$service"
		_torrent
	fi
	if $localdata ; then
		if ! $torrent ; then
			echo -e "Device:\t\t$localdevice"
			echo -e "Service:\t$service"
		fi
		_local
		if $dnsinfo ; then
			_dns
		fi
	else
		if $dnsinfo ; then
			_dns
			if ! $torrent ; then
				echo -e "Device:\t\t$localdevice"
				echo -e "Service:\t$service"
			fi
		fi
	fi
fi

if $lgeo ; then
	if [[ $(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -I 2>/dev/null) == "AirPort: Off" ]] ; then
		echo -e "Geolocation:\t-"
	else
		_geo
		if $address && ! $geo_error ; then
			ccount=0
			while true
			do
				[[ $ccount -eq 3 ]] && break
				addrinfo=$(curl -sL --connect-timeout 10 --max-time 10 -X POST -d locate="$latitude,$longitude" -d geoit="XML" "https://geocode.xyz" 2>/dev/null)
				if echo "$addrinfo" | head -1 | grep -q "geodata" &>/dev/null ; then
					break
				else
					addrinfo=""
				fi
				((ccount++))
				sleep 2
			done
			if ! [[ $addrinfo ]] ; then
				fulladdr="-"
			else
				city=$(echo "$addrinfo" | grep "\<city\>" | awk '!a[$0]++' | head -1 | awk -F"[><]" '{print $3}')
			 	if ! [[ $city ]] ; then
			 		fulladdr="-"
			 	else
			 		state=$(echo "$addrinfo" | grep "\<region\>" | awk '!a[$0]++' | head -1 | awk -F"[><]" '{print $3}')
			 		if ! [[ $state ]] ; then
			 			state=$(echo "$addrinfo" | grep "\<state\>" | awk '!a[$0]++' | head -1 | awk -F"[><]" '{print $3}')
			 			! [[ $state ]] && state="-"
			 		fi
					country=$(echo "$addrinfo" | grep "\<country\>" | awk '!a[$0]++' | head -1 | awk -F"[><]" '{print $3}')
					! [[ $country ]] && country="-"
					postal=$(echo "$addrinfo" | grep "\<postal\>" | awk '!a[$0]++' | head -1 | awk -F"[><]" '{print $3}')
					! [[ $postal ]] && postal="-"
					stnumber=$(echo "$addrinfo" | grep "\<stnumber\>" | awk '!a[$0]++' | head -1 | awk -F"[><]" '{print $3}')
					! [[ $stnumber ]] && stnumber="-"
					staddress=$(echo "$addrinfo" | grep "\<staddress\>" | awk '!a[$0]++' | head -1 | awk -F"[><]" '{print $3}')
					! [[ $staddress ]] && staddress="-"
					fulladdr="$stnumber $staddress, $city $postal, $state, $country"
				fi
			fi
			echo -e "Address:\t$fulladdr"
		fi
		if $maps && ! $geo_error ; then
			am_url="https://maps.apple.com/?q=$latitude,$longitude&t=m"
			gm_url="https://maps.google.com/maps?ll=$latitude,$longitude&q=$latitude,$longitude&hl=en&t=m&z=19"
			osm_url="https://www.openstreetmap.org/?mlat=$latitude&mlon=$longitude&zoom=19&layers=M"
			echo -e "Apple Maps:\t$am_url"
			echo -e "Google Maps:\t$gm_url"
			echo -e "OSM:\t\t$osm_url"
		fi
		if $share && ! $geo_error ; then
			if ! command -v terminal-share &>/dev/null ; then
				echo -e "ERROR:\tSharing function requires terminal-share: https://github.com/mattt/terminal-share"
			else
				sharetext="I am currently here:\n\nAddress: $fulladdr\nCoordinates: $latitude,$longitude\n\nApple Maps: $am_url\nGoogle Maps: $gm_url\nOpenStreetMap: $osm_url\n\nShared with: $process v$vno"
				finalsharetext=$(echo -e "\"$sharetext\"")
				if $message ; then
					terminal-share -service message -text "$finalsharetext" 2>/dev/null &
				elif $email ; then
					terminal-share -service email -text "$finalsharetext" 2>/dev/null &
				fi
			fi
		fi
	fi
fi

if $fullip ; then
	echo -e "Details:\thttps://dnslytics.com/ip/$publicip"
fi

exit 0
